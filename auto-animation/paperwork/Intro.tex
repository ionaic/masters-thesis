
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
%                                                                 %
%                           INTRODUCTION                          %
%                                                                 %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
 
\chapter{INTRODUCTION}
\label{chapter:intro}

% magical first sentence
% explain like you would to your parents/non-technological people
% - explain how keyframe animation currently works
% explain in more technical terms what this means
% - problems with current techniques
% - what can be done (auto animation)
% - overview of controllers
% - overview of the technique
Animations of human characters are used heavily in video games, movies, and other fields.  Especially with the increasing usage of complex environment traversal in both film and video games, many similar animations of athletic motions must be created with small changes to tune the motion to the particular situation, environment, and character.  Creation of such animations is largely done by hand by artists, posing the character for each time step of the animation.  In 2D animation this takes the form of a sprite sheet as shown in Figure \ref{fig:sprite_sheet}.  These sprites may be drawn by hand or generated through 3D models.

In 3D artists will frequently use a method called key framing, a modification of a method used for producing 2D animations.  In a key frame animation, certain ``key'' parts of the animated sequence are specified, with the remaining frames filled in in a process called "in betweening or ``tweening,'' using an automated interpolation method or manual frame addition.  For 2D animation, the artist will need to generate the intermediate images themselves or have a program interpolate between images.  In 3D, key frame animations are performed on a 3D model, storing transformation data about the model for each frame and playing back the animation by repeating the transformations, interpolating between them to produce smooth animations.

% figure of sprite animation frames
\begin{figure}[htp]
    \centering
    \includegraphics[width=\textwidth]{images/sprite_example/platformer_sprites_jump.png}
    \includegraphics[width=\textwidth]{images/sprite_example/platformer_sprites_walk.png}
    \caption[Example of a 2D Sprite Animation]{This example shows a 2D sprite sheet used to produce a jumping animation (top row) and a walking animation (bottom row) for a stick figure character.  The frames in this case are laid out in a single image for demonstration purposes, progressing in order starting with frame 0, the frame farthest left in this sprite sheet.  An artist may create key frames and then fill in intermediary poses to produce a full sprite sheet as above.  These sprite sheets were created by Clint Bellanger using a 3D model and are licensed under Creative Commons Attribution 3.0, retrieved from opengameart.org.}
    \label{fig:sprite_sheet}
\end{figure}

%3D models are described as a mesh, a collection of primitive polygons (i.e. quadrilaterals or triangles) which are stored as vertices.  This mesh describes what is drawn, including any texture, color, and other material information.  Along with the mesh, a skeleton, or rig, is stored.  The rig describes a hierarchical structure of bones and accompanying joints.  Each vertex is given a series of weights describing the impact each joint has on its transformation.  This allows many vertices, and therefore many polygons, to be transformed at once in organized groups, simplifying the problem of animating the model to a matter of transforming the skeleton in the desired manner.  To animate this 3D model, an artist specifies key frames of the animation by positioning the skeleton at different time steps.  The stored key frames, instead of an image, are the transformations of each joint at this frame or step of the animation, which a rendering or game engine can interpolate between to produce the final result.

Specifying these animation frames is work intensive, taking up significant time and resources to produce for a single character.  Additionally, similar animations may need to be produced for slightly different scenarios, with only minor modifications required.  These minor modifications can be made to fit a different setting, such as a character jumping on Earth or on the moon, or can be for different characters, such as a large person moving in contrast with a small child.  Though the movement itself may be similar, manual changes must be made, requiring artist time which could be spent generating new assets.  

Recent work in animation generation seeks to automate this process, replacing the manual process with a procedural one.  Physics-based simulations can be used to produce controllers for the skeleton, determining joint positions and rotations for keyframes automatically.  Not only does this reduce the effort involved in the creation process, but this also provides a basis for dynamic interaction between a character's animation and the environment.  With manual keyframe animations this is not possible, as any specific interaction between a character and the environment must be manually created by an animator 

We present a controller that takes a skeleton as input, with additional parameters describing the character.  We then simulate a jumping motion on the character, determining a sequence of poses based on the character's muscles to produce a keyframe animation.  The additional character parameters describe the character's mass, muscles, the constraints placed on each joint to prevent unnatural rotations, and a description of the jump indicating desired time and distance.  Mass is specified per-limb, with each mass stored in the joint object affecting the limb to allow for calculation of the character's center of mass.  

\newcommand{\frameimage}[1]{\fbox{\includegraphics[scale=1.0]{#1}}}

\begin{figure}[htp]
	\centering
	\begin{subfigure}[h]{0.16\textwidth}
		\frameimage{images/jump_stages/ps1_windup.png}
		\caption{Windup}
	\end{subfigure}
	\begin{subfigure}[h]{0.32\textwidth}
		\frameimage{images/jump_stages/ps2_takeoff.png}
		\caption{Takeoff}
	\end{subfigure}
	\begin{subfigure}[h]{0.48\textwidth}
		\frameimage{images/jump_stages/ps3_airborne.png}
		\caption{In-Air}
	\end{subfigure}
	%\includegraphics[width=\textwidth]{images/jump_stages/jump_stages.png}
	\caption[Example of stages of jumping]{Above is an example 2D sprite animation of a simple human character jumping, with the jump divided into the windup, takeoff, and in-air stages.  A landing is absent from this sequence.  The windup consists of a short crouch to prepare for the jump, creating an opportunity for the body to extend and thus accelerate.  The takeoff performs this acceleration, shifting its center of mass forward past its feet and the character becomes airborne.  During the in-air phase the character moves its body to control the fall, in this case spreading its arms and shifting its feet from behind its pelvis to in front of its pelvis.}
	\label{fig:jumpStages}
\end{figure}

We divide a jump into five stages: path estimation, windup, thrust, in air maneuvering, and landing. Our controller works with the initial path estimation, windup, and thrust stages of the motion as shown in Figure \ref{fig:jumpStages}.  Poses are  calculated by modeling muscles as Hookean springs attached to the skeleton at 2 points and crossing a joint as shown in Figure \ref{fig:forceCalc}. Spring constants for the muscles are specified by the user, allowing our simulation to animate characters of various strengths and body makeups.  Spring displacement from rest is calculated using the bend in the joint and constants describing the skeleton.  Using the spring displacement, a particular pose of a joint is related to the usage of the character's muscle and the elasticity of the connective tissue of the muscle and joint.

Two approaches are described in this thesis, one using torque and one using elastic energy.  As the springs contract, they produce forces on the bones, which result in torques at each joint.  These torques are then used to calculate a windup pose for the character by calculating resultant linear acceleration for the character's center of mass, which is compared to a calculated necessary acceleration to make the jump.  This linear acceleration is then used to compute the motion of the takeoff and in-air phases of the jump, which are sampled to create frames of an animation.  Our second approach uses the spring displacement to calculate the elastic potential energy of each muscle, which is modeled by a single linear spring.  By assuming perfect conservation of energy, we compare the total elastic potential energy of the character's muscles to a calculated necessary kinetic energy for the jump to be completed.

To control the motion and maintain plausibility, we calculate the character's center of mass and supporting polygon each frame.  This allows the character to maintain balance while flexing its joints, the position of the character's joints are adjusted to keep the center of mass positioned over the supporting polygon.  While flexing, the character constantly checks the position of its center of mass against the calculated supporting polygon, ensuring the center of mass is over the support and as close to the center as possible.

We use an inverse kinematic solver to help determine poses of intermediate joints.  This allows us to find the necessary pose for the ankle and knee of the character given the position of its foot and hip.  Many solutions in this region are possible, so we constrain the skeleton such that only those poses where the joints are within human ranges of motion are possible.

The next stage of the motion is the thrust stage where the character releases from the ground by using the potential energy of the spring-muscles to accelerate its center of mass upward.  This is handled by applying the calculated accelerations from the windup stage to the character's pelvis to accelerate the center of mass, with the inverse kinematic solver determining the poses of the legs as they unbend.  Balance must be maintained, and the relative rate of rotation of the different joints of the leg must be balanced with each other to maintain foot position while the body is transformed.  As the skeleton is a tree with its root at the character's pelvis, this can be a challenge, necessitating the use of the inverse kinematics solver.  Due to the nature of the inverse kinematics algorithm used, the extension propagates from the hip to the feet.  

The character then proceeds through the in-air portion of the jump, where the acceleration changes due to gravity before they finally land.  We assume a simple trajectory for the in-air phase, though more complex motions with turns, flips, or interaction with the environment could be created.  Our simulation ends when the character's feet contact the ground, ending the in-air phase.  Other work, such as that by \liufall, has handled landing and creating a separate controller to handle this is beyond the scope of this thesis. \cite{falling_landing}

Our controller is made to be a module, able to be used with other controllers as part of a larger system.  Its modularity is in the form of detecting and handling its state at each stage, consisting of its position, velocity, acceleration, pose, muscle state, and any collisions or forces applied. The controller performs actions when it has a response to its current state and ends control when it no longer has an appropriate response to allow a separate controller to handle the situation.  This allows each controller to do a smaller job well. Several such controllers can be connected to produce more complex animations or animation sequences, utilizing bounded starting and finishing conditions for the character as well as bounds on expected conditions during operation to allow handling of stimuli during operation.

% figure of current keyframe animation process in maya
% accompanying video for presentation
% accompanying figure/video of the resulting animation in 3d

 
\section{An Example of Animation Creation}
\label{section:anim_ex}
To motivate the necessity for an automated animation method, we present an example of the method for producing an animation by hand.  First a mesh and rig must be produced, which we also require for our simulation.  This is a time and skill intensive process, requiring the artist to exercise their technical and creative knowledge and ability to create the character's figure, the mesh, and to create and attach a skeleton, the rig.  The mesh is constructed of faces which are in turn made of vertices, and each vertex must be assigned a weight for each joint of the rig to indicate the way the vertex should transform when the joint in the rig is transformed.  These joints serve not only as a joint in the anatomical sense, but as a tracked point in the skeleton.  The joints are connected by bones, but the information is stored at the joint, which sometimes necessitates a joint to be placed in a non-anatomical way.  For example, in our rig we have a joint placed at the head, which not only allows us to rotate the head but tracks the position.  A similar situation arises with the toe and heel, where a joint is used to facilitate the placement of a connecting bone.  Once the mesh and rig are created and the weights for the rig are assigned to the mesh, an animator may create controls to manipulate several joints at once, such as creating a controller to facilitate grasping motions in which many bones of the hand must be manipulated at once.  These controls are formed from an object such as a simple spline to which several joints are constrained, allowing movement of several joints through manipulation of the control object.

Once the rig and mesh are set up, an animator must manipulate the mesh to pose the model.  Study of real subjects may be used to help ensure realism, suc  For a jumping motion they would need to decide how they want to start the animation to allow blending from other movements such as walking, running, or standing.  They must then position the model and record a key frame.  Key frames are hand-created frames of the animation which a renderer or game engine may interpolate between to produce a final animation, allowing an animator to create and store few frames, while still creating a 60 frame per second animation in the final setting.  This also allows few frames to be stored to produce any frame rate of animation, while also reducing the storage requirements in exchange for a minor increase in computation, which is an extra interpolation for each joint in the character.

While the key frames can be sparse and there are tools for aiding in generation, this process requires heavy manual input for each animation for each character, as well as prior knowledge of the motion to be produced.  Characters that move differently due to differences in weight or body makeup must be animated separately, requiring an artist to perform similar, time consuming work.  For example, a character with extremely strong legs may bend less, applying the same force as a weaker character over a shorter distance to achieve the same acceleration.  A heavier character would need to apply much more force to achieve the same acceleration and thus jump height as a lighter character, necessitating stronger muscles or a greater distance over which the force is applied, thus requiring a deeper squat than the light character.  With a simulation-based approach this work could be reduced, especially repeated work, to setting variables such as weight, height, and musculature for the different characters and generating the set of animations desired.  As techniques and technologies improve, a simulation could be used in place of a stored key frame animation, creating the animation in place based on its environment and situation, thus shifting the burden on an animator from preparing poses and keyframes to adjusting body dimensions, weight, strength, and constraints.

For a jump specifically, a human loads the muscles in their legs, quickly moving to a particular bend based on the feedback they feel in their muscles and joints, as well as balance feedback and their knowledge of the jumps they have performed in the past.  The appearance of bearing and lifting weight is difficult to achieve, as the animator must visually match the poses to their knowledge of bodies or to a visual of a similar human to their character performing the motion.  Simulation allows a computer to calculate movement based on physical aspects of the character, incorporating knowledge such as the character's weight and body make up, allowing an animator to produce animations of unfamiliar motions with a higher degree of physical plausibility.

% explain contributions
% - what is the contribution of this technique
% - Unity3D -> what am I getting from outside sources
% - what am I making myself

\section{Contributions}
	This thesis describes a controller which simulates a jumping motion of a character.  The generated animation is created to be plausible in appearance, using a simplified physical representation.  We sacrifice some physical accuracy in favor of speed and simplicity of creating, describing, and implementing the simulation.  Specifically, we contribute a description for the windup, thrust, and in air phases of a jump and created a controller using a physical simulation and an implementation in \unity{}.  In short, our contributions are:
	\begin{itemize}
		\item A controller which simulates a windup and thrust phase of a jump, moving the character from the ground into the air
		\item A description of character poses based on torque generated by muscles
		\item A description of character poses based on elastic energy of the muscles
		\item A sampling-based method for choosing a pose given muscles and a desired output
		%\item Estimates and quantification of ``good'' values for spring constants
		\item Visualizations of the animations and values for analysis and presentation
	\end{itemize}

\subsection{\unity{}}
	To help separate the work performed for this thesis from features provided by \unity{}, we give a brief description of what \unity{} provides.  \unity{} was chosen due to familiarity, lack of cost, and the selection of features available.  While we chose \unity{}, this system could be implemented in other engines, requiring that the engine provides rendering, physics, and scene management capabilities, which are provided by most game engines.
	
	\unity{} is a game engine which we used to develop this system.  It provides infrastructure for rendering, scene management, skeletal animation, asset import and management, lighting, and scripting.  Our simulation leverages the provided features through the \unity{} scripting interface, which allows a developer to write scripts in C\# to use the functions available.  We developed scripts for calculation of muscle forces, as well as for applying the force to an imported model.  Models were created in \maya{} and imported using \unity{}'s asset import as \unity{} \typename{GameObject}s with attached \typename{Transform} components which allow arbitrary transformations.  The skeleton, specified in \maya{}, was imported as a tree with each joint as a separate \typename{GameObject} node of the tree, with a parent \typename{GameObject} as the root node, which also was parent to the \typename{GameObject}s carrying the created mesh.
	
	\unity{} tracks and manages each \typename{GameObject}, running the update loop for the user.  \unity{} uses a component-object model, where \typename{GameObjects} are given behaviors by having a particular \typename{Component}.  Each \typename{Component} has several different update functions for different stages of the engine's pipeline such as \funcname{FixedUpdate} for fixed spacing of calls instead of actually calling once per frame or \funcname{OnPostRender} for operations performed after rendering, but the main function is \funcname{Update}, which is called every frame.  Components allow rendering and simulation behaviors to be separated from each other, decoupling them from each other and the objects.  The update loop handles rendering related updates as well as running \funcname{Update} for each component on the object.  Our simulation is implemented as several \typename{Component} scripts attached to the character, with additional \typename{Component}s to carry extra information with each joint of the skeleton and \typename{Component}s on each hip for inverse kinematic solving.  The scene manager provided by \unity{} allows for simple access and manipulation of these \typename{Component}s and their objects, managing many useful data structures, namely the tree of all objects present in the scene.
	
	\unity{} also provides matrix and vector math libraries as well as generalized math libraries to aid in physics calculations and subsequent transformations on the objects.  There are rigid body and physics components available, but for the purposes of our simulation we performed the physics calculations ourselves to gain greater control.  We utilized \unity{} ray casts for detecting collisions between the character's feet and the floor.
	
	\begin{figure}[ht]
		\centering
		\includegraphics[width=\textwidth]{images/unityEditor.png}
		\caption[Screenshot of the \unity{} Editor]{Pictured is the \unity{} Editor.  At left a representation of the scene called the Hierarchy, allowing for visualization and manipulation of the tree of objects that make up the scene.  At right is the Inspector, showing the interface for setting and editing the values specified in our simulation, the JumpController Component.  In the center is a visual of the scene, allowing for intuitive placement and manipulation of objects, showing the character.  At the bottom is a window showing console output and errors.  These windows may be moved by the user.}
		\label{fig:unity_interface}
	\end{figure}	
	
	For managing the numerous user-specified values, we use the \unity{} Inspector.  \unity{} provides the Unity Editor for creating and managing scenes and objects within, which is depicted in Figure \ref{fig:unity_interface}.  Within the Editor the Inspector is a window showing the \typename{Component}s attached to the selected \typename{GameObject}.  \unity{} utilizes serialization to allow public class variables to be set and modified through the Inspector, providing a form of fields into which numbers can be entered.  Using this, we allow the user to specify the desired constants for the simulation.
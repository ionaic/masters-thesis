
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
%                                                                 %
%                           INTRODUCTION                          %
%                                                                 %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
 
\chapter{INTRODUCTION}
\label{chapter:intro}

% magical first sentence
% explain like you would to your parents/non-technological people
% - explain how keyframe animation currently works
% explain in more technical terms what this means
% - problems with current techniques
% - what can be done (auto animation)
% - overview of controllers
% - overview of the technique
Animations of human characters are used heavily in video games, movies, and other fields.  Especially with the increasing usage of complex environment traversal in both film and video games, many similar animations of athletic motions must be created with small changes to tune the motion to the particular situation, environment, and character.  Creation of such animations is largely done by hand by artists, posing the character for each time step of the animation.  In 2D animation this takes the form of a sprite sheet as shown in Figure \ref{fig:sprite_sheet}.  These sprites may be drawn by hand or generated through 3D models.

In 3D artists will frequently use a method called key framing, a modification of a method used for producing 2D animations.  In a key frame animation, certain ``key'' parts of the animated sequence are specified, with the remaining frames filled in in a process called "in betweening or ``tweening,'' using an automated interpolation method or manual frame addition.  For 2D animation, the artist will need to generate the intermediate images themselves or have a program interpolate between images.  In 3D, key frame animations are performed on a 3D model, storing transformation data about the model for each frame and playing back the animation by repeating the transformations, interpolating between them to produce smooth animations.

% figure of sprite animation frames
\begin{figure}[htp]
    \centering
    \includegraphics[width=\textwidth]{images/sprite_example/platformer_sprites_jump.png}
    \includegraphics[width=\textwidth]{images/sprite_example/platformer_sprites_walk.png}
    \caption[Example of a 2D Sprite Animation]{This example shows a 2D sprite sheet used to produce a jumping animation (top row) and a walking animation (bottom row) for a stick figure character.  The frames in this case are laid out in a single image for demonstration purposes, progressing in order starting with frame 0, the frame farthest left in this sprite sheet.  An artist may create key frames and then fill in intermediary poses to produce a full sprite sheet as above.  These sprite sheets were created by Clint Bellanger using a 3D model and are licensed under Creative Commons Attribution 3.0, retrieved from opengameart.org.}
    \label{fig:sprite_sheet}
\end{figure}

%3D models are described as a mesh, a collection of primitive polygons (i.e. quadrilaterals or triangles) which are stored as vertices.  This mesh describes what is drawn, including any texture, color, and other material information.  Along with the mesh, a skeleton, or rig, is stored.  The rig describes a hierarchical structure of bones and accompanying joints.  Each vertex is given a series of weights describing the impact each joint has on its transformation.  This allows many vertices, and therefore many polygons, to be transformed at once in organized groups, simplifying the problem of animating the model to a matter of transforming the skeleton in the desired manner.  To animate this 3D model, an artist specifies key frames of the animation by positioning the skeleton at different time steps.  The stored key frames, instead of an image, are the transformations of each joint at this frame or step of the animation, which a rendering or game engine can interpolate between to produce the final result.

Specifying these animation frames is work intensive, taking up significant time and resources to produce for a single character.  Additionally, similar animations may need to be produced for slightly different scenarios, with only minor modifications required.  These minor modifications can be made to fit a different setting, such as a character jumping on Earth or on the moon, or can be for different characters, such as a large person moving in contrast with a small child.  Though the movement itself may be similar, manual changes must be made, requiring artist time which could be spent generating new assets.  

Recent work in animation generation seeks to automate this process, replacing the manual process with a procedural one.  Physics-based simulations can be used to produce controllers for the skeleton, determining joint positions and rotations for keyframes automatically.  Not only does this reduce the effort involved in the creation process, but this also provides a basis for dynamic interaction between a character's animation and the environment, which is not possible with manual keyframe animations.

We present a controller that takes a skeleton as input, with additional parameters describing the character.  We then simulate a jumping motion on the character, determining a sequence of poses based on the character's muscles to produce a series of frames of an animation.  The additional character parameters describe the character's mass, muscles, the constraints placed on each joint to prevent unnatural rotations, and a description of the jump indicating desired time and distance.  Mass is specified per-joint to allow for calculation of the character's center of mass.  

We divide a jump into five stages: path estimation, windup, thrust, in air maneuvering, and landing. Our controller works with the initial path estimation, windup, and thrust stages of the motion.  Poses are  calculated by modeling muscles as Hookean springs attached to the skeleton at 2 points and crossing a joint. Spring constants for the muscles are specified by the user, allowing our simulation to animate characters of various strengths and body makeups.  Spring displacement from rest is calculated using the bend in the joint and constants describing the skeleton.  Using the spring displacement, a particular pose of a joint is related to the usage of the character's muscle.

Two approaches are described in this thesis, one using torque and one using elastic energy.  As the springs contract, they produce forces on the bones, which result in torques at each joint.  These torques are then used to calculate a pose for the character by calculating resultant linear acceleration for the character's center of mass, which is compared to a calculated necessary acceleration to make the jump.  Our second approach uses the spring displacement to calculate the elastic potential energy of each muscle.  By assuming perfect conservation of energy, we compare the total elastic potential energy of the character's muscles to a calculated necessary kinetic energy for the jump to be completed.

To control the motion and maintain plausibility, we calculate the character's center of mass and supporting polygon each frame.  This allows the character to maintain balance while flexing its joints, the position of the character's joints are adjusted to keep the center of mass positioned over the supporting polygon.  While flexing, the character constantly checks the position of its center of mass against the calculated supporting polygon, ensuring the center of mass is over the support and as close to the center as possible.

We use an inverse kinematic solver to help determine poses of intermediate joints.  This allows us to find the necessary pose for the ankle and knee of the character given the position of its foot and hip.  Many solutions in this region are possible, so we constrain the skeleton such that only those poses where the joints are within human ranges of motion are possible.

The next stage of the motion is the thrust stage where the character releases from the ground by using the potential energy of the spring-muscles to accelerate its center of mass upward.  This is handled by applying the calculated accelerations from the windup stage to the character's pelvis to accelerate the center of mass, with the inverse kinematic solver determining the poses of the legs as they unbend.  Due to the nature of the inverse kinematics algorithm used, the extension propagates from the hip to the feet.  

The character then proceeds through the in-air portion of the jump, where the acceleration changes due to gravity as well as other forces before they finally land.  We assume a simple trajectory for the in-air phase, though more complex motions with turns, flips, or interaction with the environment could be created.  Our simulation ends when the character's feet contact the ground, ending the in-air phase.  Other work, such as that by \liufall, has handled landing and creating a separate controller to handle this is beyond the scope of this thesis. \cite{falling_landing}

Our controller is made to be a module, able to be used with other controllers as part of a larger system.  Its modularity is in the form of detecting and handling its condition at each stage, performing actions when it has a response to its current condition and ending control when it no longer has an appropriate response to allow a separate controller to handle the situation.  This allows each controller to do a smaller job well. Several such controllers can be connected to produce more complex animations or animation sequences, utilizing bounded starting and finishing conditions for the character.

% figure of current keyframe animation process in maya
% accompanying video for presentation
% accompanying figure/video of the resulting animation in 3d

 
\section{An Example of Animation Creation}
\label{section:anim_ex}
To motivate the necessity for an automated animation method, we present an example of the method for producing an animation by hand.  First a mesh and rig must be produced, which we also require for our simulation.  This is a time and skill intensive process, requiring the artist to exercise their technical and creative knowledge and ability to create the character's figure, the mesh, and to create and attach a skeleton, the rig.  The mesh is composed of vertices, and each vertex must be assigned a weight for each joint of the rig to indicate the way the vertex should transform when the joint in the rig is transformed.  These joints serve not only as a joint in the anatomical sense, but as a tracked point in the skeleton.  The joints are connected by bones, but the information is stored at the joint, which sometimes necessitates a joint to be placed in a non-anatomical way.  For example, in our rig we have a joint placed at the head, which not only allows us to rotate the head but tracks the position.  A similar situation arises with the toe and heel, where a joint is used to facilitate the placement of a connecting bone.  Once the mesh and rig are created and the weights for the rig are assigned to the mesh, an animator may create controls to manipulate several joints at once, such as for hand or arm movements.  These controls are formed from an object such as a simple spline to which several joints are constrained, allowing movement of several joints through manipulation of the control object.

Once the rig and mesh are set up, an animator must manipulate the mesh to pose the model.  For a jumping motion they would need to decide how they want to start the animation to allow blending from other movements such as walking, running, or standing.  They must then position the model and record a key frame.  Key frames are hand-created frames of the animation which a renderer or game engine may interpolate between to produce a final animation, allowing an animator to create and store few frames, while still creating a 60 frame per second animation in the final setting.  This also allows few frames to be stored to produce any frame rate of animation, while also reducing the storage requirements in exchange for a minor increase in computation, which is an extra interpolation for each joint in the character.

While the key frames can be sparse and there are tools for aiding in generation, this process requires heavy manual input for each animation for each character.  Characters that move differently due to differences in weight or body makeup must be animated separately, requiring an artist to perform similar, time consuming work.  With a simulation-based approach this work could be reduced, especially repeated work, to setting variables such as weight, height, and musculature for the different characters and generating the set of animations desired.  As techniques and technologies improve, a simulation could be used in place of a stored key frame animation, creating the animation in place based on its environment and situation.

For a jump specifically, a human loads the muscles in their legs, quickly moving to a particular bend based on the feedback they feel in their muscles and joints, as well as balance feedback and their knowledge of the jumps they have performed in the past.  The appearance of bearing and lifting weight is difficult to achieve, as the animator must visually match the poses to their knowledge of bodies or to a visual of a similar human to their character performing the motion.  Simulation allows a computer to calculate movement based on physical aspects of the character, incorporating knowledge such as the character's weight and body make up, allowing an animator to produce animations of motions they are less familiar with with a higher degree of accuracy.

% explain contributions
% - what is the contribution of this technique
% - Unity3D -> what am I getting from outside sources
% - what am I making myself

\section{Contributions}
	This thesis describes a controller which simulates a jumping motion on a character.  The generated animation is created to be plausible in appearance, using a simplified physical representation.  We sacrifice some physical accuracy in favor of speed and simplicity of creating, describing, and implementing the simulation.  Specifically, we contribute a description for the windup, thrust, and in air phases of a jump and created a controller using a physical simulation and an implementation in \unity{}.  In short, our contributions are:
	\begin{itemize}
		\item A controller which simulates a windup and thrust phase of a jump, moving the character from the ground into the air
		\item A description of character poses based on torque generated by muscles
		\item A description of character poses based on elastic energy of the muscles
		\item A sampling-based method for choosing a pose given muscles and a desired output
		%\item Estimates and quantification of ``good'' values for spring constants
		\item Visualizations of the animations and values for analysis and presentation
	\end{itemize}

\subsection{\unity{}}
	To help separate the work performed for this thesis from features provided by \unity{}, we give a brief description of what \unity{} provides.  This also helps motivate our choice of the engine, though an implementation using a different tool could fit better into the existing work flow used for creation of animations.
	
	\unity{} is a game engine which we used to develop this system.  It provides infrastructure for rendering, scene management, skeletal animation, asset import and management, lighting, and scripting.  Our simulation leverages the provided features through the \unity{} scripting interface, which allows a developer to write scripts in C\# to use the functions available.  We developed scripts for calculation of muscle forces, as well as for applying the force to an imported model.  Models were created in \maya{} and imported using \unity{}'s asset import as \unity{} GameObjects with attached Transform components which allow arbitrary transformations.  The skeleton, specified in \maya{}, was imported as a tree with each joint as a separate GameObject node of the tree, with a parent GameObject as the root node, which also was parent to the GameObjects carrying the created mesh.
	
	\unity{} tracks and manages each GameObject, running the update loop for the user.  \unity{} uses a component-object model, where GameObjects are given behaviors by having a particular Component.  Each component has a various update functions for different stages of the engine's pipeline, but the main function is Update.  Components allow rendering and simulation behaviors to be separated from each other, decoupling them from each other and the objects.  The update loop handles rendering related updates as well as running Update for each component on the object.  Our simulation is implemented as several Component scripts attached to the character, with additional Components to carry extra information with each joint of the skeleton and Components on each hip for inverse kinematic solving.  The scene manager provided by \unity{} allows for simple access and manipulation of these Components and their objects, managing many useful data structures, namely the tree of all objects present in the scene.   
	
	\unity{} also provides matrix and vector math libraries as well as generalized math libraries to aid in physics calculations and subsequent transformations on the objects.  There are rigid body and physics components available, but for the purposes of our simulation we performed the physics calculations ourselves to gain greater control.  We utilized \unity{} ray casts for detecting collisions between the character's feet and the floor.
	
	\begin{figure}[ht]
		\centering
		\includegraphics[width=\textwidth]{images/unityEditor.png}
		\caption[Screenshot of the \unity{} Editor]{Pictured is the \unity{} editor.  At left a representation of the scene, allowing for visualization and manipulation of the hierarchy of objects.  At right is the inspector, showing the interface for setting and editing the values specified in our simulation, the JumpController Component.  In the center is a visual of the scene, allowing for intuitive placement and manipulation of objects, showing the character.}
		\label{fig:unity_interface}
	\end{figure}	
	
	For managing the numerous user specified values, we use the \unity{} inspector.  \unity{} provides an editor for creating and managing scenes and objects within, which is depicted in Figure \ref{fig:unity_interface}.  Within this editor the inspector is a window showing the Components attached to the selected GameObject.  \unity{} utilizes serialization to allow public class variables to be set and modified through the inspector, providing a form of fields into which numbers can be entered.  Using this, we allow the user to specify the desired constants for the simulation.
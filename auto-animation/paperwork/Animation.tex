%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
%                                                                 %
%                             Animation                           %
%                                                                 %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
 
\chapter{ANIMATION}
\label{chapter:animation}

Jumping is the acceleration of a character's center of mass upward.  This motion can be divided into several stages.  First is the lead-up or wind-up stage in which the character flexes or gathers momentum to perform the jump.  This takes the form of a slight crouch (TODO reference cat jumping paper or the background .  should this be in background?) which prepares the character to exert the necessary force against the ground.  

Next comes the take-off stage.  The character pushes against the floor with their feet, accelerating their center of mass to break contact with the floor.  

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%               Torque Method                 %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Torque-based simulation}
One method of simulation we attempted used springs placed along the length of each limbs to produce a torque on the joints of the character.  This method failed for unknown reasons.  Torques on the joints results from the force of the muscle pulling a bone to rotate about the joint, resulting in a complex system of motion with each bone rotating around the joints.  These rotations combine to move the body in a direction, allowing a character's control to be centered around degree and timing of muscle activation. \cite{muscle_based_bipeds}  In our case, we take the muscle as fully activated, which means that it has a spring constant defining the strength of the muscle.  This muscle is then stretched to produce the desired torque by bending the affected limb.  The restoring force of the spring-muscles produce torques which are used to calculate angular momentum, and from that linear momentum.  

\subsection{Path Estimation}

\begin{figure}[ht]
	\centering
	\input{images/algorithm_diagram/pathEstimate.tex}
	\caption[Diagram of path estimation algorithm]{Diagram of the path estimation step.}
	\label{fig:pathEstimate}
\end{figure}

\begin{figure}[ht]
	\label{fig:pathExample}
	\caption[Example of estimated path]{Example of a path estimation.}
\end{figure}
Before calculations relating to the model's skeleton are performed, an initial estimate of the jump path is performed.  The estimate uses a simple forward kinematic calculation to determine the force required to move an object through the air from the initial position of the model, denoted as $x_0$ in Figure \ref{fig:pathEstimate}, to a final position, denoted as $x$.  To facilitate a character jumping while moving, the path estimate takes into account the initial velocity $v_0$.

The user specifies a desired time ($t$), which indicates the time the character will spend airborne during the animation, i.e. the time between when the character's feet break contact with the ground and when they regain contact with the ground.  This is useful as the desired animation can be more easily adjusted to fit a desired time as an in-game animation or to fit a particular storyboard for an animated film sequence.

\subsection{Windup}
From this force, the acceleration can be determined using $F=ma$ from classical mechanics.  This assumes the character is a rigid body with negligible air resistance acted upon by gravity of $10\frac{m}{s}$.  The mass is calculated as the summed total of the distributed masses assigned to the character's limbs, which are summed to produce a total mass for the character.

Proportional derivative control is used to produce the windup motion once the initial path estimate is calculated.  The error function $E_{all}$ calculates error from the desired force $E_{force}$ as well as the balance $E_{balance}$.

Once computed, error is compared to a threshold ($\epsilon$).  If the error is below the threshold, the skeleton is considered bent to the proper position for windup and the system proceeds to the thrust phase in which the character unbends.  If the value is above the threshold, a new position for the hip is calculated using proportional-derivative control, where the new position for the iteration of the controller, $u(i)$, is calculated as \[u(i) = k_p E_{all}(i - 1) + k_d(E_{all}(i-1) - E_{all}(i-2))\] where $i$ is the iteration, and $k_p$ and $k_d$ are weights which determine the rate of change. This new hip position is given to an inverse kinematics component to calculate the positions of the remaining leg joints, assuming the feet should remain in the same position.  These new joint positions and angles are then passed back to the PD controller to re-calculate the center of mass as well as the new force and balance errors for the next iteration.

\begin{figure}[ht]
	\centering
	\resizebox{\textwidth}{!}{
		\input{images/algorithm_diagram/bendPhase.tex}
	}
	\caption[Diagram of windup phase algorithm]{Algorithm diagram of the windup phase.}
	\label{fig:bendPhase}
	%TODO decision lines need to be labeled
\end{figure}

\begin{table}[ht]
	\centering
	\caption[Table of PD controller constants for windup phase]{Example values for the PD controller constants, showing the sweet spot that we use as well as the effect of going higher or lower (how do we show this effect, show that the steps are too large or too small? time or iterations to finish?).}
	\label{tab:windup_pd_vals}
\end{table}

\subsubsection{Force calculation}
%TODO force calculation should be done with error in net torque instead of error in force as we don't really have a resultant force here and the net force really means nothing
% calculation of the muscle flexion
\begin{figure}[ht]
	\centering
	\includegraphics[width=10cm]{images/spring_calc/spring_angle_calc.eps}
	\caption[Diagram of joint force calculation]{Force calculation for a joint.}
	\label{fig:forceCalc}
\end{figure}
Current force is computed by approximating muscles as linear springs attached to two bones and crossing a joint.  The change in spring length is produced by the bend of the joint which opens a space between the rigid bones that the spring must stretch across.  This approximation uses spring constants that simulate a flexed muscle that has been stretched by an amount equal to \[\theta = cos^{-1} \left( \dfrac{2 k^2 r^2}{F^2} - 1 \right)\] which requires a more rigid spring constant.  In this equation, $r$, represents the width of the bone, which is a constant that changes the amount the character must bend to achieve a force.  This acts similarly to the $k$ value, which represents the stiffness of the spring, or a constant for the linear restoring force of the muscle.  
%TODO For our simulations, we used values in the range ().
%TODO values and equation
%TODO tables of values with varied k and varied r and corresponding bend/angle
\begin{table}[ht]
	\centering
	\caption[Table of spring muscle constants]{A table of various values for k and r, demonstrating effect on the model's bend.  TODO Columns of k and r (varied individually), and image of fully bent character resulting from values.}
	\label{tab:variedSpringValues}
\end{table}

At each iteration of the PD controller, current force output of the legs is computed.  An accurate calculation of the force must take into account the torques ($\vec{\tau}$) produced by the muscles on each joint.  We use a simplified version, calculating the magnitudes of the torques which avoids the complexity of implementation and computation.  This is found for a joint j as \[\tau_j = ||\vec{r_j}|| F_j\] where r is the moment arm, the cross product between the vector between the attachment point of muscle and the center of the joint with the direction of the muscle crossing the joint.  Direction of a muscle is in the direction of restoration of the spring (TODO double check this, is this always the value we want, point placed along the spring based on the masses on each end) as used in \cite{muscle_based_bipeds}.
%TODO does this setup effectively result in springs connected in series? No because you can assume that the muscles you don't want to unbend with remain rigid?
%TODO does this give a sort of impulse function as you unbend at the hips and knees, then the ankles?
%TODO this is where the torques come into play, and they're absolutely necessary

\begin{figure}[ht]
	\centering
	\caption[Algorithm diagram for calculation of force error]{Force error calculation}
	\label{fig:forceErr}
\end{figure}

To calculate the error used for PD control, the vector between the two forces is measured, indicating the change required in both direction and magnitude.  As we require the force to act in the direction of acceleration, the main adjustment is the force magnitude.  When instead considering the torque magnitude, the magnitude alone can be considered. (TODO I think I need to be using the torque magnitude instead of a force here).

\subsubsection{Center of Mass and Balance}
%TODO need to standardize usage of joint to anatomical, animation, or something else
The center of mass (CoM) is calculated as the centroid of the character.  More specifically, joint positions are averaged, with a weight assigned to each joint based on the weight of the limb associated.  The CoM must be recalculated with each update to the character's pose as the shift in weight changes the position.

Using the calculated CoM, the balance of the character can be determined by the position of the CoM relative to the supporting polygon of the character.  The supporting polygon is a polygon determined by the points of contact of the character with the ground or other supports which provide a normal force to counteract gravity and other external forces.  During the windup and thrust phases, the character maintains contact with the ground through their feet, with the outer edges of the feet forming two sides of a quad, a line between the two feet at the toes forming a third, and a line between the heels of the character forming the fourth side.  This polygon should be parallel to the ground plane, and is positioned at the bottom of the feet.  If the character's center of mass is over this supporting polygon, the character is balanced.

\begin{figure}[ht]
	\centering
	\caption[Algorithm diagram for calculation of balance error]{Balance error calculation.}
	\label{fig:balanceErr}
\end{figure}

To quantify balance, the vector between the center of the supporting polygon and the position of the CoM is measured.  This vector is then projected into the same plane as the supporting polygon, giving a 2 dimensional error between where the CoM is currently and where it would need to be to be perfectly centered.  The PD controller then attempts to minimize the magnitude of this vector by moving in the proscribed direction while bending to achieve the desired force, constraining the number of solutions possible to provide the desired force.
% does the vertical distance have effect?  you're going to fall over more easily if you're on a stilt as opposed to crouching over your feet as the moment will be (bigger? is that bigger?).  the lever will be more able to move your weight easily

\subsubsection{Inverse Kinematic Solving}
As the skeleton is a hierarchy assumed to be rooted at the hip, a problem arises with applying rotations to joints.  To keep a character's feet rooted to the floor as is expected, positions must be solved for using inverse kinematics.  Given the desired position for the hip, and the desired position of the foot, the joint angles and positions of the knee and ankle are solved for.  Constraints are placed on each joint, limiting the range of motion to an expected range as well as limiting the axes about which each joint can rotate, preventing unnatural directions of motion.  These values are specified per joint and can be edited by the user to simulate varied levels of flexibility or alternate body shapes.

%TODO alternate body with digitigrade, Tauren or whatever from WoW, raptor style...
%TODO Further justification of why choosing this method instead of learning is that this is more user-tunable as opposed to a learning heavy model which doesn't allow as much user tuning

\begin{table}[ht]
	\centering
	\caption[Table of joint constraints]{Joint angle constraint values used for each joint, with accompanying images of expected motion range.}
	\label{tab:jointConstraints}
\end{table}

A solution to the joint positions is found using these constraints, and gradient descent method which works on single-chains of joints.  A single chain of joints is a sequence of joints in which each joint has a single child and a single parent, with one root joint and one leaf joint which lack a parent and child respectively.  Given the hierarchy of joints and a desired position for one of the non-root nodes of the chain, cyclic-coordinate descent (CCD) is used to determine rotations of the joints between the joint in question and the root that will minimize the distance between the joint in question and the desired position.  This algorithm is shown in \ref{alg:ik}.

\begin{algorithm}[ht]
	\centering
	\begin{algorithmic}[H]
		\Function{SingleChainIK}{C, D, E}
		\Repeat
		\ForAll{Joints R between E and the root, starting with the end E}
			\State $\theta_R = \vec{RD} \times \vec{RE}$
		\EndFor
		\Until{\textit{Desired number of iterations performed} or \textbf{E} \textit{is close enough to} \textbf{D}}
		\EndFunction
	\end{algorithmic}
	\caption[Single chain IK algorithm]{Given chain of joints C, move joint E to position D using cyclic coordinate descent (TODO cite CCD references).  This process iteratively moves joint E closer to the location D, concentrating on each joint R in the chain one at a time and solving the geometric problem of minimizing distance between E and D by rotating R.}
	\label{alg:ik}
\end{algorithm}

This approach, while for the specific case of single chains of joints, is simpler to implement than other approaches such as the pseudo-inverse of the Jacobian.  In addition, this approach allows some flexibility, specifically in constraints of the joints.  As each joint is addressed individually instead of the system as a whole, any constraints placed on the joint can easily be accounted for by simply preventing the joint from rotating out of the desired range while the rest of the system continues to move as close as possible to the solution.  One downside is that a halting condition must be determined, through a minimum acceptable distance.  To handle the case where the joint cannot be moved within this minimum distance, a maximum number of iterations must be designated.  In practice, 100 iterations is enough to converge, with as few as 30 working well for our simulation.

\subsection{Thrust and Takeoff}
Upward acceleration is animated by calculating the angular accelerations of the joints given the forces acting upon them and the resulting torques.  Torque is the change in angular momentum over time, allowing for the acceleration to be calculated as the mass can be assumed to be constant: \[\tau = \dfrac{dL}{dt} = m \dfrac{dv_{\theta}}{dt} = m a_{\theta}\] where $\tau$ is the torque of a joint, $L$ is the angular momentum, $m$ is the mass of the limb, which must take into account the mass of the rest of the body which is also moved by the limb, $v_{\theta}$ is the angular velocity and $a_{\theta}$ is the angular acceleration. This results in the below equation for determining angular acceleration. \[a_{\theta} = \dfrac{\tau}{m}\]

Using angular acceleration, the intermediary poses for the model can be determined at each timestep.   For each frame, an explicit Euler integration is performed to determine first angular velocity and finally angle.  As the character continues to extend, a check is made for if the character has yet reached full extension.  At full extension, the character can no longer accelerate in the direction of the jump, and the character breaks contact with the ground to enter the in-air phase.

\subsection{Sampling}
To determine which of numerous possible solutions is the most desirable, we take several samples.  A sample is described by the position of the pelvis joint, the resulting linear momentum, and a vector describing the displacement of the character's center of mass from the center of its support to indicate balance as described above.

Samples were restricted to a box defined by a rectangle around the character's feet with a height reaching the position of the character's pelvis when standing at rest.  Any sample outside of this volume is assumed to put the character off balance.  Samples were then taken at uniformly distributed positions in this region.  To select the minimum sample, the collected data were organized first by the difference between the linear momentum calculated and the desired linear momentum, and the top ten percent were selected.  Ten percent was found empirically to be a good selection of points to select the most balanced from while also retrieving points with very low differences from the desired.

\subsection{Rebalancing}
As the character re-positions its pelvis, the balance must be calculated again and its position accordingly re-adjusted.  

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%               Energy                %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Energy based calculation}


\section{Summary}
\label{subsection:animation_summary}